% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BetterVis_DotPlot_Heatmap.R
\name{BetterVis_DotPlot_Heatmap}
\alias{BetterVis_DotPlot_Heatmap}
\title{Create a Highly Customized Dot Plot or Heatmap}
\usage{
BetterVis_DotPlot_Heatmap(
  data_matrix,
  scale = TRUE,
  rescale = FALSE,
  rescale.range = c(0, 3),
  dotplot = TRUE,
  dots.type = "square root",
  dots.size = 4,
  show.noexpr.dots = FALSE,
  col.min = ifelse(isTRUE(scale), -2, 0),
  col.max = ifelse(isTRUE(scale), 2, "q100"),
  data.colors = if (isTRUE(scale)) c("#1289B2", "#FCF6AF", "#E53849") else "Viridis",
  palette.reverse = FALSE,
  na.color = "grey40",
  background.color = "white",
  order.idents = NULL,
  order.colors = TRUE,
  kmeans.repeats = 100,
  cluster.idents = TRUE,
  idents.kmeans = 1,
  idents.kmeans.numbers.size = 11,
  cluster.features = TRUE,
  features.kmeans = 1,
  features.kmeans.numbers.size = 11,
  idents.gap = 1,
  features.gap = 1,
  idents.names.size = 9,
  features.names.size = 9,
  features.names.style = "italic",
  row.names.side = "left",
  column.names.angle = 45,
  column.names.side = "bottom",
  inner.border = TRUE,
  data.legend.name = ifelse(isTRUE(scale), "Z-Score", "Average Expression"),
  show.data.legend = TRUE,
  legend.title.size = 10,
  legend.text.size = 10,
  legend.gap = 10,
  row_annotation_color = NULL,
  row_annotation_legend = FALSE,
  row.split = NULL,
  col.split = NULL,
  border_gp_control = FALSE,
  right.annotation = FALSE,
  bottom.annotation = FALSE,
  top.annotation = FALSE,
  keep_rownames_order = TRUE,
  zscore.legend = TRUE,
  zscore.legend.side = "bottom",
  zscore.legend.direction = "horizontal",
  zscore.legend.position = "topcenter",
  zscore.legend.width = 5,
  col_annotation_legend = FALSE,
  col_annotation_color = NULL,
  col_annotation_legend_title = "Columns",
  row_annotation_legend_title = "Rows",
  ...
)
}
\arguments{
\item{data_matrix}{A numeric matrix for plotting. Rows typically represent features (e.g., genes) and columns represent groups (e.g., cell types).}

\item{scale}{Logical. If `TRUE`, the matrix is z-score scaled by row. Default is `TRUE`.}

\item{rescale}{Logical. If `TRUE` and `scale` is `FALSE`, the data is rescaled to a new range. Default is `FALSE`.}

\item{rescale.range}{Numeric vector of length 2 specifying the new range for rescaling. Default is `c(0, 3)`.}

\item{dotplot}{Logical. If `TRUE`, creates a dot plot where dot size represents presence/absence. If `FALSE`, creates a standard heatmap. Default is `TRUE`.}

\item{dots.type}{Character. Method for scaling dot size, currently only "square root" is implemented.}

\item{dots.size}{Numeric. A scaling factor for the maximum dot size. Default is `4`.}

\item{show.noexpr.dots}{Logical. If `TRUE`, dots for zero-value cells are shown at a minimal size. Default is `FALSE`.}

\item{col.min, col.max}{The minimum and maximum values for the color scale. Can be numeric or a quantile string (e.g., "q1"). Defaults are adjusted based on `scale`.}

\item{data.colors}{A character vector of 2 or 3 colors for the gradient, or a palette name like "Viridis".}

\item{palette.reverse}{Logical. If `TRUE`, reverses the color palette. Default is `FALSE`.}

\item{na.color}{Color for `NA` values. Default is `"grey40"`.}

\item{order.idents}{Character vector or "reverse". Specifies a custom order for rows or reverses the default order.}

\item{cluster.idents, cluster.features}{Logical. Whether to perform k-means clustering on rows or columns.}

\item{idents.kmeans, features.kmeans}{Integer. The number of k-means clusters for rows and columns.}

\item{features.names.size, idents.names.size}{Numeric. Font size for column and row names.}

\item{legend.title.size, legend.text.size}{Numeric. Font sizes for legend titles and text.}

\item{row_annotation_color, col_annotation_color}{(Optional) A vector of colors for row/column annotations.}

\item{row_annotation_legend, col_annotation_legend}{Logical. Whether to display the legend for row/column annotations.}

\item{row.split, col.split}{A numeric or character vector to split the heatmap rows/columns into groups.}

\item{right.annotation, top.annotation, bottom.annotation}{Logical. Toggles display of annotations on different sides.}

\item{keep_rownames_order}{Logical. If `TRUE`, forces the row order to match the input matrix. Default is `TRUE`.}

\item{zscore.legend, show.data.legend}{Logical. Toggles display of the main data legend.}

\item{row_annotation_legend_title, col_annotation_legend_title}{Character. Titles for the annotation legends.}

\item{...}{Additional arguments passed to `ComplexHeatmap::Heatmap`.}
}
\value{
A `HeatmapList` object, which is automatically drawn to the graphics device.
}
\description{
This function serves as a sophisticated wrapper for the `ComplexHeatmap` package,
allowing for the creation of intricate heatmaps and dot plots. It offers extensive
customization options for scaling, clustering, annotations, colors, and layout.
}
\examples{
\dontrun{
# Load example data and create color vectors
data("BetterVis_DotPlot_Heatmap_example", package = "BetterVis")
library(RColorBrewer)
row_colors <- c(brewer.pal(9,"Set3"), brewer.pal(8,"Set2"))
col_colors <- c(brewer.pal(8,"Set1"), brewer.pal(5,"Set2"))

# Generate the plot with extensive customization
BetterVis_DotPlot_Heatmap(
  data_matrix = BetterVis_DotPlot_Heatmap_example,
  scale = FALSE,
  col.min = 0,
  col.max = 2,
  show.noexpr.dots = TRUE,
  data.colors = c("#1289B2", "#FCF6AF", "#E53849"),
  dots.size = 3,
  dots.type = "square root",
  inner.border = FALSE,
  cluster.features = FALSE,
  cluster.idents = FALSE,
  row.names.side = "right",
  idents.names.size = 10,
  column.names.side = "top",
  column.names.angle = 45,
  features.names.size = 10,
  top.annotation = TRUE,
  row_annotation_color = row_colors,
  col_annotation_color = col_colors,
  show.data.legend = TRUE,
  row_annotation_legend = TRUE,
  row_annotation_legend_title = "Rows",
  col_annotation_legend = TRUE,
  col_annotation_legend_title = "Cols",
  zscore.legend = TRUE,
  zscore.legend.side = "bottom",
  row.split = c(rep(1,4), rep(2,4), rep(3,4), rep(4,4), 5),
  col.split = c(rep(4,3), 5, 3, rep(1,5), 2, 5, 2)
)
}
}
